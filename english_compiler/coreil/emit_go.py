"""Go code generator for Core IL.

This file implements Core IL v1.9 to Go transpilation.

The generated Go code:
- Matches interpreter semantics exactly
- Uses coreil_runtime.go for runtime support (copied alongside output)
- All values are of type Value (dynamically typed struct)
- Implements short-circuit evaluation
- Supports all Core IL v1.9 features

Version history:
- v1.9: Initial Go backend

Backward compatibility: Accepts v0.1 through v1.9 programs.
"""

from __future__ import annotations

from pathlib import Path

from english_compiler.coreil.emit_base import BaseEmitter


class GoEmitter(BaseEmitter):
    """Go code emitter for Core IL."""

    @property
    def indent_str(self) -> str:
        return "\t"

    def _setup_state(self) -> None:
        """Initialize Go-specific state."""
        self._sc_counter = 0
        self._func_names: set[str] = set()

    def _next_sc_var(self) -> str:
        """Generate unique variable name for short-circuit evaluation."""
        self._sc_counter += 1
        return f"__sc{self._sc_counter}"

    def emit(self) -> str:
        """Generate Go code from Core IL document."""
        body = self.doc.get("body", [])
        func_defs = [stmt for stmt in body if stmt.get("type") == "FuncDef"]
        main_stmts = [stmt for stmt in body if stmt.get("type") != "FuncDef"]

        # Collect function names first
        for stmt in func_defs:
            self._func_names.add(stmt.get("name", ""))

        # Generate function definitions
        for stmt in func_defs:
            self.emit_stmt(stmt)
            self.emit_line("")

        # Generate main function
        self.emit_line("func main() {")
        self.indent_level = 1
        for stmt in main_stmts:
            self.emit_stmt(stmt)
        self.indent_level = 0
        self.emit_line("}")

        return self._build_output()

    def _build_output(self) -> str:
        """Build final output with headers."""
        header_lines = [
            "// Generated by English Compiler - Core IL to Go transpiler",
            "package main",
            "",
        ]
        return "\n".join(header_lines + self.lines) + "\n"

    # ========== Expression Handlers ==========

    def _emit_literal(self, node: dict) -> str:
        value = node.get("value")
        if isinstance(value, str):
            escaped = self.escape_string(value)
            return f'ValueStr("{escaped}")'
        elif isinstance(value, bool):
            return "ValueBool(true)" if value else "ValueBool(false)"
        elif value is None:
            return "ValueNone"
        elif isinstance(value, int):
            return f"ValueInt({value})"
        elif isinstance(value, float):
            return f"ValueFloat({value})"
        raise ValueError(f"unsupported literal type: {type(value)}")

    def _emit_short_circuit(self, node: dict, *, eval_right_on_truthy: bool) -> str:
        """Emit short-circuit and/or using Go's func literal for lazy eval."""
        left = self.emit_expr(node.get("left"))
        right = self.emit_expr(node.get("right"))
        if eval_right_on_truthy:
            # and: if left truthy, evaluate right; else false
            return (
                f"func() Value {{ __l := {left}; "
                f"if isTruthy(__l) {{ __r := {right}; return ValueBool(isTruthy(__r)) }} "
                f"else {{ return ValueBool(false) }} }}()"
            )
        else:
            # or: if left truthy, true; else evaluate right
            return (
                f"func() Value {{ __l := {left}; "
                f"if isTruthy(__l) {{ return ValueBool(true) }} "
                f"else {{ __r := {right}; return ValueBool(isTruthy(__r)) }} }}()"
            )

    def _emit_binary(self, node: dict) -> str:
        op = node.get("op")

        if op == "and":
            return self._emit_short_circuit(node, eval_right_on_truthy=True)
        elif op == "or":
            return self._emit_short_circuit(node, eval_right_on_truthy=False)

        left = self.emit_expr(node.get("left"))
        right = self.emit_expr(node.get("right"))

        op_map = {
            "+": "valueAdd",
            "-": "valueSubtract",
            "*": "valueMultiply",
            "/": "valueDivide",
            "%": "valueModulo",
        }

        if op in op_map:
            return f"{op_map[op]}({left}, {right})"
        elif op == "==":
            return f"ValueBool(valueEqual({left}, {right}))"
        elif op == "!=":
            return f"ValueBool(!valueEqual({left}, {right}))"
        elif op == "<":
            return f"ValueBool(valueLessThan({left}, {right}))"
        elif op == "<=":
            return f"ValueBool(valueLessThanOrEqual({left}, {right}))"
        elif op == ">":
            return f"ValueBool(valueGreaterThan({left}, {right}))"
        elif op == ">=":
            return f"ValueBool(valueGreaterThanOrEqual({left}, {right}))"
        else:
            raise ValueError(f"unknown binary operator: {op}")

    def _emit_array(self, node: dict) -> str:
        items = node.get("items", [])
        if not items:
            return "ValueArray(nil)"
        item_strs = [self.emit_expr(item) for item in items]
        return "ValueArray([]Value{" + ", ".join(item_strs) + "})"

    def _emit_index(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        index = self.emit_expr(node.get("index"))
        return f"arrayIndex({base}, {index})"

    def _emit_slice(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        start = self.emit_expr(node.get("start"))
        end = self.emit_expr(node.get("end"))
        return f"arraySlice({base}, {start}, {end})"

    def _emit_not(self, node: dict) -> str:
        arg = self.emit_expr(node.get("arg"))
        return f"logicalNot({arg})"

    def _emit_length(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"arrayLength({base})"

    def _emit_call_expr(self, node: dict) -> str:
        name = node.get("name")
        args = node.get("args", [])
        arg_strs = [self.emit_expr(arg) for arg in args]
        return f"{name}({', '.join(arg_strs)})"

    def _emit_map(self, node: dict) -> str:
        items = node.get("items", [])
        if not items:
            return "ValueMapEmpty()"
        pairs = []
        for item in items:
            key = self.emit_expr(item.get("key"))
            value = self.emit_expr(item.get("value"))
            pairs.append(f"{{{key}, {value}}}")
        return "ValueMapNew([]struct{ K, V Value }{" + ", ".join(pairs) + "})"

    def _emit_get(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        key = self.emit_expr(node.get("key"))
        return f"mapGet({base}, {key})"

    def _emit_get_default(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        key = self.emit_expr(node.get("key"))
        default = self.emit_expr(node.get("default"))
        return f"mapGetDefault({base}, {key}, {default})"

    def _emit_keys(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"mapKeys({base})"

    def _emit_tuple(self, node: dict) -> str:
        items = node.get("items", [])
        item_strs = [self.emit_expr(item) for item in items]
        return "ValueTupleNew([]Value{" + ", ".join(item_strs) + "})"

    def _emit_record(self, node: dict) -> str:
        fields = node.get("fields", [])
        if not fields:
            return "ValueRecordNew(nil)"
        field_strs = []
        for field in fields:
            name = field.get("name")
            value = self.emit_expr(field.get("value"))
            field_strs.append(f'{{"{name}", {value}}}')
        return "ValueRecordNew([]struct{ Name string; Val Value }{" + ", ".join(field_strs) + "})"

    def _emit_get_field(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        name = node.get("name")
        return f'recordGetField({base}, "{name}")'

    def _emit_string_length(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"stringLength({base})"

    def _emit_substring(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        start = self.emit_expr(node.get("start"))
        end = self.emit_expr(node.get("end"))
        return f"stringSubstring({base}, {start}, {end})"

    def _emit_char_at(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        index = self.emit_expr(node.get("index"))
        return f"stringCharAt({base}, {index})"

    def _emit_join(self, node: dict) -> str:
        sep = self.emit_expr(node.get("sep"))
        items = self.emit_expr(node.get("items"))
        return f"stringJoin({sep}, {items})"

    def _emit_string_split(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        delimiter = self.emit_expr(node.get("delimiter"))
        return f"stringSplit({base}, {delimiter})"

    def _emit_string_trim(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"stringTrim({base})"

    def _emit_string_upper(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"stringUpper({base})"

    def _emit_string_lower(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"stringLower({base})"

    def _emit_string_starts_with(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        prefix = self.emit_expr(node.get("prefix"))
        return f"stringStartsWith({base}, {prefix})"

    def _emit_string_ends_with(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        suffix = self.emit_expr(node.get("suffix"))
        return f"stringEndsWith({base}, {suffix})"

    def _emit_string_contains(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        substring = self.emit_expr(node.get("substring"))
        return f"stringContains({base}, {substring})"

    def _emit_string_replace(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        old = self.emit_expr(node.get("old"))
        new = self.emit_expr(node.get("new"))
        return f"stringReplaceFn({base}, {old}, {new})"

    def _emit_set_expr(self, node: dict) -> str:
        items = node.get("items", [])
        if not items:
            return "ValueSetNew(nil)"
        item_strs = [self.emit_expr(item) for item in items]
        return "ValueSetNew([]Value{" + ", ".join(item_strs) + "})"

    def _emit_set_has(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        value = self.emit_expr(node.get("value"))
        return f"setHas({base}, {value})"

    def _emit_set_size(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"setSize({base})"

    def _emit_deque_new(self, node: dict) -> str:
        return "ValueDequeNew()"

    def _emit_deque_size(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"dequeSize({base})"

    def _emit_heap_new(self, node: dict) -> str:
        return "ValueHeapNew()"

    def _emit_heap_size(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"heapSize({base})"

    def _emit_heap_peek(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"heapPeek({base})"

    def _emit_math(self, node: dict) -> str:
        op = node.get("op")
        arg = self.emit_expr(node.get("arg"))
        math_funcs = {
            "sin": "mathSin", "cos": "mathCos", "tan": "mathTan",
            "sqrt": "mathSqrt", "floor": "mathFloor", "ceil": "mathCeil",
            "abs": "mathAbs", "log": "mathLog", "exp": "mathExp",
        }
        if op not in math_funcs:
            raise ValueError(f"unknown math operation: {op}")
        return f"{math_funcs[op]}({arg})"

    def _emit_math_pow(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        exponent = self.emit_expr(node.get("exponent"))
        return f"mathPow({base}, {exponent})"

    def _emit_math_const(self, node: dict) -> str:
        name = node.get("name")
        if name == "pi":
            return "mathPi()"
        elif name == "e":
            return "mathE()"
        raise ValueError(f"unknown math constant: {name}")

    def _unsupported(self, node: dict) -> str:
        raise ValueError(
            f"{node.get('type')} is not supported in the Go backend."
        )

    _emit_json_parse = _unsupported
    _emit_json_stringify = _unsupported
    _emit_regex_match = _unsupported
    _emit_regex_find_all = _unsupported
    _emit_regex_replace = _unsupported
    _emit_regex_split = _unsupported

    def _emit_external_call(self, node: dict) -> str:
        module = node.get("module")
        function = node.get("function")
        raise ValueError(
            f"ExternalCall to {module}.{function} is not supported in Go backend."
        )

    def _emit_method_call(self, node: dict) -> str:
        obj = self.emit_expr(node.get("object"))
        method = node.get("method")
        args = node.get("args", [])
        arg_strs = [self.emit_expr(arg) for arg in args]
        return f"{obj}.{method}({', '.join(arg_strs)})"

    def _emit_property_get(self, node: dict) -> str:
        obj = self.emit_expr(node.get("object"))
        prop = node.get("property")
        return f"{obj}.{prop}"

    def _emit_to_int(self, node: dict) -> str:
        value = self.emit_expr(node.get("value"))
        return f"valueToInt({value})"

    def _emit_to_float(self, node: dict) -> str:
        value = self.emit_expr(node.get("value"))
        return f"valueToFloat({value})"

    def _emit_to_string(self, node: dict) -> str:
        value = self.emit_expr(node.get("value"))
        return f"valueToStringConvert({value})"

    # ========== Statement Handlers ==========

    def _emit_let(self, node: dict) -> None:
        name = node.get("name")
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"{name} := {value}")

    def _emit_assign(self, node: dict) -> None:
        name = node.get("name")
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"{name} = {value}")

    def _emit_if(self, node: dict) -> None:
        test = self.emit_expr(node.get("test"))
        self.emit_line(f"if isTruthy({test}) {{")
        self.indent_level += 1
        then_body = node.get("then", [])
        if not then_body:
            self.emit_line("// empty")
        else:
            for stmt in then_body:
                self.emit_stmt(stmt)
        self.indent_level -= 1

        else_body = node.get("else")
        if else_body:
            self.emit_line("} else {")
            self.indent_level += 1
            for stmt in else_body:
                self.emit_stmt(stmt)
            self.indent_level -= 1
        self.emit_line("}")

    def _emit_while(self, node: dict) -> None:
        test_expr = node.get("test")
        test = self.emit_expr(test_expr)
        self.emit_line("for {")
        self.indent_level += 1
        self.emit_line(f"if !isTruthy({test}) {{ break }}")
        body = node.get("body", [])
        for stmt in body:
            self.emit_stmt(stmt)
        self.indent_level -= 1
        self.emit_line("}")

    def _emit_print(self, node: dict) -> None:
        args = node.get("args", [])
        arg_strs = [self.emit_expr(arg) for arg in args]
        self.emit_line(f"coreilPrint([]Value{{{', '.join(arg_strs)}}})")

    def _emit_set_index(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        index = self.emit_expr(node.get("index"))
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"arraySetIndex({base}, {index}, {value})")

    def _emit_set_stmt(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        key = self.emit_expr(node.get("key"))
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"mapSet({base}, {key}, {value})")

    def _emit_push(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"arrayPush({base}, {value})")

    def _emit_set_field(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        name = node.get("name")
        value = self.emit_expr(node.get("value"))
        self.emit_line(f'recordSetField({base}, "{name}", {value})')

    def _emit_set_add(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"setAdd({base}, {value})")

    def _emit_set_remove(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"setRemove({base}, {value})")

    def _emit_push_back(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"dequePushBack({base}, {value})")

    def _emit_push_front(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"dequePushFront({base}, {value})")

    def _emit_pop_front(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        target = node.get("target")
        self.emit_line(f"{target} := dequePopFront({base})")

    def _emit_pop_back(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        target = node.get("target")
        self.emit_line(f"{target} := dequePopBack({base})")

    def _emit_heap_push(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        priority = self.emit_expr(node.get("priority"))
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"heapPush({base}, {priority}, {value})")

    def _emit_heap_pop(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        target = node.get("target")
        self.emit_line(f"{target} := heapPop({base})")

    def _emit_func_def(self, node: dict) -> None:
        name = node.get("name")
        params = node.get("params", [])
        param_strs = [f"{p} Value" for p in params]
        self.emit_line(f"func {name}({', '.join(param_strs)}) Value {{")
        self.indent_level += 1
        body = node.get("body", [])
        if not body:
            self.emit_line("return ValueNone")
        else:
            for stmt in body:
                self.emit_stmt(stmt)
            if body and body[-1].get("type") != "Return":
                self.emit_line("return ValueNone")
        self.indent_level -= 1
        self.emit_line("}")

    def _emit_return(self, node: dict) -> None:
        value = node.get("value")
        if value is None:
            self.emit_line("return ValueNone")
        else:
            self.emit_line(f"return {self.emit_expr(value)}")

    def _emit_call_stmt(self, node: dict) -> None:
        name = node.get("name")
        args = node.get("args", [])
        arg_strs = [self.emit_expr(arg) for arg in args]
        self.emit_line(f"{name}({', '.join(arg_strs)})")

    def _emit_break(self, node: dict) -> None:
        self.emit_line("break")

    def _emit_continue(self, node: dict) -> None:
        self.emit_line("continue")

    def _emit_for(self, node: dict) -> None:
        var = node.get("var")
        iter_expr = node.get("iter")
        body = node.get("body", [])

        if isinstance(iter_expr, dict) and iter_expr.get("type") == "Range":
            from_val = self.emit_expr(iter_expr.get("from"))
            to_val = self.emit_expr(iter_expr.get("to"))
            inclusive = iter_expr.get("inclusive", False)
            cmp_op = "<=" if inclusive else "<"
            self.emit_line("{")
            self.indent_level += 1
            self.emit_line(f"__from := asInt({from_val})")
            self.emit_line(f"__to := asInt({to_val})")
            self.emit_line(f"for __from {cmp_op} __to {{")
            self.indent_level += 1
            self.emit_line(f"{var} := ValueInt(__from)")
            # Suppress unused variable warning
            self.emit_line(f"_ = {var}")
            for stmt in body:
                self.emit_stmt(stmt)
            self.emit_line("__from++")
            self.indent_level -= 1
            self.emit_line("}")
            self.indent_level -= 1
            self.emit_line("}")
        else:
            iter_code = self.emit_expr(iter_expr)
            self.emit_line("{")
            self.indent_level += 1
            self.emit_line(f"__iter := asArray({iter_code})")
            self.emit_line("for _, __item := range *__iter {")
            self.indent_level += 1
            self.emit_line(f"{var} := __item")
            self.emit_line(f"_ = {var}")
            for stmt in body:
                self.emit_stmt(stmt)
            self.indent_level -= 1
            self.emit_line("}")
            self.indent_level -= 1
            self.emit_line("}")

    def _emit_for_each(self, node: dict) -> None:
        var = node.get("var")
        iter_code = self.emit_expr(node.get("iter"))
        body = node.get("body", [])

        self.emit_line("{")
        self.indent_level += 1
        self.emit_line(f"__iter := asArray({iter_code})")
        self.emit_line("for _, __item := range *__iter {")
        self.indent_level += 1
        self.emit_line(f"{var} := __item")
        self.emit_line(f"_ = {var}")
        for stmt in body:
            self.emit_stmt(stmt)
        self.indent_level -= 1
        self.emit_line("}")
        self.indent_level -= 1
        self.emit_line("}")

    def _emit_throw(self, node: dict) -> None:
        message = self.emit_expr(node.get("message"))
        self.emit_line(f"panic(formatValue({message}))")

    def _emit_try_catch(self, node: dict) -> None:
        catch_var = node.get("catch_var")
        body = node.get("body", [])
        catch_body = node.get("catch_body", [])
        finally_body = node.get("finally_body")

        # Go uses defer/recover for panic handling
        # We wrap in a func() to scope the recover
        self.emit_line("{")
        self.indent_level += 1

        if finally_body:
            # Emit finally as deferred block
            self.emit_line("defer func() {")
            self.indent_level += 1
            for stmt in finally_body:
                self.emit_stmt(stmt)
            self.indent_level -= 1
            self.emit_line("}()")

        self.emit_line("func() {")
        self.indent_level += 1
        self.emit_line("defer func() {")
        self.indent_level += 1
        self.emit_line("if __r := recover(); __r != nil {")
        self.indent_level += 1
        self.emit_line(f'{catch_var} := ValueStr(fmt.Sprintf("%v", __r))')
        self.emit_line(f"_ = {catch_var}")
        for stmt in catch_body:
            self.emit_stmt(stmt)
        self.indent_level -= 1
        self.emit_line("}")
        self.indent_level -= 1
        self.emit_line("}()")
        for stmt in body:
            self.emit_stmt(stmt)
        self.indent_level -= 1
        self.emit_line("}()")

        self.indent_level -= 1
        self.emit_line("}")


def emit_go(doc: dict) -> str:
    """Generate Go code from Core IL document.

    Returns Go source code as a string.
    """
    emitter = GoEmitter(doc)
    return emitter.emit()


def get_runtime_path() -> Path:
    """Return the path to the coreil_runtime.go runtime file."""
    return Path(__file__).parent / "go_runtime" / "coreil_runtime.go"
