"""Rust code generator for Core IL.

This file implements Core IL v1.10 to Rust transpilation.

The generated Rust code:
- Matches interpreter semantics exactly
- Uses coreil_runtime.rs for runtime support (included via include!)
- All values are of type Value (dynamically typed enum)
- Implements short-circuit evaluation via block expressions
- Record support (mutable named fields)
- Set operations (membership, add, remove, size)
- Deque operations (double-ended queue)
- Heap operations (min-heap priority queue)
- Math operations (sin, cos, tan, sqrt, floor, ceil, abs, log, exp, pow, pi, e)
- JSON operations (pure Rust recursive descent parser/serializer)
- Regex operations (pure Rust NFA-based engine)
- Array slicing (Slice)
- Unary not (Not)
- Break and Continue loop control
- OOP-style method calls and property access (Tier 2)
- Exception handling via panic/catch_unwind (TryCatch, Throw)

Version history:
- v1.10: Added JSON and Regex support (pure Rust, no external crates)
- v1.8: Initial Rust backend

Backward compatibility: Accepts v0.1 through v1.10 programs.
"""

from __future__ import annotations

from pathlib import Path

from english_compiler.coreil.emit_base import BaseEmitter


class RustEmitter(BaseEmitter):
    """Rust code emitter for Core IL."""

    @property
    def indent_str(self) -> str:
        return "    "

    def _setup_state(self) -> None:
        """Initialize Rust-specific state."""
        self.external_modules: set[str] = set()
        self._sc_counter = 0

    def _next_sc_var(self) -> str:
        """Generate unique variable name for short-circuit evaluation."""
        self._sc_counter += 1
        return f"__sc{self._sc_counter}"

    def emit(self) -> str:
        """Generate Rust code from Core IL document."""
        # Separate function definitions from main body
        body = self.doc.get("body", [])

        # Build index mapping: original body index -> statement
        body_indices = list(range(len(body)))
        func_def_indices = [i for i in body_indices if body[i].get("type") == "FuncDef"]
        main_indices = [i for i in body_indices if body[i].get("type") != "FuncDef"]

        # Generate function definitions
        for i in func_def_indices:
            start = len(self.lines)
            self.emit_stmt(body[i])
            self.emit_line("")
            end = len(self.lines)
            self.coreil_line_map[i] = list(range(start, end))

        # Generate main function
        self.emit_line("fn main() {")
        self.indent_level = 1
        for i in main_indices:
            start = len(self.lines)
            self.emit_stmt(body[i])
            end = len(self.lines)
            self.coreil_line_map[i] = list(range(start, end))
        self.indent_level = 0
        self.emit_line("}")

        return self._build_output()

    def _build_output(self) -> str:
        """Build final output with headers."""
        header_lines = [
            "// Generated by English Compiler - Core IL to Rust transpiler",
            "",
            'include!("coreil_runtime.rs");',
            "",
        ]

        # Add non-portable warning if external modules used
        if self.external_modules:
            header_lines.insert(0, "// WARNING: This program uses external calls and is NOT PORTABLE")
            header_lines.insert(1, f"// Required external modules: {', '.join(sorted(self.external_modules))}")
            header_lines.insert(2, "")

        # Shift coreil_line_map by the number of header lines
        offset = len(header_lines)
        self.coreil_line_map = {
            k: [ln + offset for ln in v]
            for k, v in self.coreil_line_map.items()
        }

        return "\n".join(header_lines + self.lines) + "\n"

    # ========== Expression Handlers ==========

    def _emit_literal(self, node: dict) -> str:
        value = node.get("value")
        if isinstance(value, str):
            escaped = self.escape_string(value)
            return f'Value::Str("{escaped}".to_string())'
        elif isinstance(value, bool):
            return "Value::Bool(true)" if value else "Value::Bool(false)"
        elif value is None:
            return "Value::None"
        elif isinstance(value, int):
            return f"Value::Int({value})"
        elif isinstance(value, float):
            return f"Value::Float({value})"
        raise ValueError(f"unsupported literal type: {type(value)}")

    def _emit_short_circuit(self, node: dict, *, eval_right_on_truthy: bool) -> str:
        """Emit a short-circuit 'and'/'or' as a Rust block expression.

        For 'and': evaluate right side only when left is truthy.
        For 'or': evaluate right side only when left is falsy.
        """
        left = self.emit_expr(node.get("left"))
        var_l = self._next_sc_var()
        var_r = self._next_sc_var()
        right = self.emit_expr(node.get("right"))
        eval_right = f"let {var_r} = {right}; Value::Bool(is_truthy(&{var_r}))"
        if eval_right_on_truthy:
            truthy_branch, falsy_branch = eval_right, "Value::Bool(false)"
        else:
            truthy_branch, falsy_branch = "Value::Bool(true)", eval_right
        return (
            f"{{ let {var_l} = {left}; "
            f"if is_truthy(&{var_l}) {{ {truthy_branch} }} "
            f"else {{ {falsy_branch} }} }}"
        )

    def _emit_binary(self, node: dict) -> str:
        op = node.get("op")

        # Short-circuit operators need block expressions
        if op == "and":
            return self._emit_short_circuit(node, eval_right_on_truthy=True)
        elif op == "or":
            return self._emit_short_circuit(node, eval_right_on_truthy=False)

        left = self.emit_expr(node.get("left"))
        right = self.emit_expr(node.get("right"))

        op_map = {
            "+": "value_add",
            "-": "value_subtract",
            "*": "value_multiply",
            "/": "value_divide",
            "%": "value_modulo",
        }

        if op in op_map:
            return f"{op_map[op]}({left}.clone(), {right}.clone())"
        elif op == "==":
            return f"Value::Bool(value_equal(&{left}, &{right}))"
        elif op == "!=":
            return f"Value::Bool(!value_equal(&{left}, &{right}))"
        elif op == "<":
            return f"Value::Bool(value_less_than(&{left}, &{right}))"
        elif op == "<=":
            return f"Value::Bool(value_less_than_or_equal(&{left}, &{right}))"
        elif op == ">":
            return f"Value::Bool(value_greater_than(&{left}, &{right}))"
        elif op == ">=":
            return f"Value::Bool(value_greater_than_or_equal(&{left}, &{right}))"
        else:
            raise ValueError(f"unknown binary operator: {op}")

    def _emit_array(self, node: dict) -> str:
        items = node.get("items", [])
        if not items:
            return "make_array(vec![])"
        item_strs = [self.emit_expr(item) for item in items]
        return "make_array(vec![" + ", ".join(item_strs) + "])"

    def _emit_index(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        index = self.emit_expr(node.get("index"))
        return f"array_index(&{base}, &{index})"

    def _emit_slice(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        start = self.emit_expr(node.get("start"))
        end = self.emit_expr(node.get("end"))
        return f"array_slice(&{base}, &{start}, &{end})"

    def _emit_not(self, node: dict) -> str:
        arg = self.emit_expr(node.get("arg"))
        return f"logical_not({arg})"

    def _emit_length(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"array_length(&{base})"

    def _emit_call_expr(self, node: dict) -> str:
        name = node.get("name")
        args = node.get("args", [])

        if name == "get_or_default":
            if len(args) != 3:
                raise ValueError(f"get_or_default expects 3 arguments, got {len(args)}")
            d = self.emit_expr(args[0])
            k = self.emit_expr(args[1])
            default = self.emit_expr(args[2])
            return f"map_get_default(&{d}, &{k}, &{default})"

        if name == "entries":
            if len(args) != 1:
                raise ValueError(f"entries expects 1 argument, got {len(args)}")
            d = self.emit_expr(args[0])
            return f"map_keys(&{d})"

        if name == "append":
            if len(args) != 2:
                raise ValueError(f"append expects 2 arguments, got {len(args)}")
            lst = self.emit_expr(args[0])
            value = self.emit_expr(args[1])
            return f"{{ array_push(&{lst}, {value}); Value::None }}"

        arg_strs = [self.emit_expr(arg) + ".clone()" for arg in args]
        return f"{name}({', '.join(arg_strs)})"

    def _emit_map(self, node: dict) -> str:
        items = node.get("items", [])
        if not items:
            return "make_map(vec![])"
        pairs = []
        for item in items:
            key = self.emit_expr(item.get("key"))
            value = self.emit_expr(item.get("value"))
            pairs.append(f"({key}, {value})")
        return "make_map(vec![" + ", ".join(pairs) + "])"

    def _emit_get(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        key = self.emit_expr(node.get("key"))
        return f"map_get(&{base}, &{key})"

    def _emit_get_default(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        key = self.emit_expr(node.get("key"))
        default = self.emit_expr(node.get("default"))
        return f"map_get_default(&{base}, &{key}, &{default})"

    def _emit_keys(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"map_keys(&{base})"

    def _emit_tuple(self, node: dict) -> str:
        items = node.get("items", [])
        item_strs = [self.emit_expr(item) for item in items]
        return "make_tuple(vec![" + ", ".join(item_strs) + "])"

    def _emit_record(self, node: dict) -> str:
        fields = node.get("fields", [])
        if not fields:
            return "make_record(vec![])"
        field_strs = []
        for field in fields:
            name = field.get("name")
            value = self.emit_expr(field.get("value"))
            field_strs.append(f'("{name}".to_string(), {value})')
        return "make_record(vec![" + ", ".join(field_strs) + "])"

    def _emit_get_field(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        name = node.get("name")
        return f'record_get_field(&{base}, "{name}")'

    def _emit_string_length(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"string_length(&{base})"

    def _emit_substring(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        start = self.emit_expr(node.get("start"))
        end = self.emit_expr(node.get("end"))
        return f"string_substring(&{base}, &{start}, &{end})"

    def _emit_char_at(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        index = self.emit_expr(node.get("index"))
        return f"string_char_at(&{base}, &{index})"

    def _emit_join(self, node: dict) -> str:
        sep = self.emit_expr(node.get("sep"))
        items = self.emit_expr(node.get("items"))
        return f"string_join(&{sep}, &{items})"

    def _emit_string_split(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        delimiter = self.emit_expr(node.get("delimiter"))
        return f"string_split(&{base}, &{delimiter})"

    def _emit_string_trim(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"string_trim(&{base})"

    def _emit_string_upper(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"string_upper(&{base})"

    def _emit_string_lower(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"string_lower(&{base})"

    def _emit_string_starts_with(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        prefix = self.emit_expr(node.get("prefix"))
        return f"string_starts_with(&{base}, &{prefix})"

    def _emit_string_ends_with(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        suffix = self.emit_expr(node.get("suffix"))
        return f"string_ends_with(&{base}, &{suffix})"

    def _emit_string_contains(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        substring = self.emit_expr(node.get("substring"))
        return f"string_contains(&{base}, &{substring})"

    def _emit_string_replace(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        old = self.emit_expr(node.get("old"))
        new = self.emit_expr(node.get("new"))
        return f"string_replace_fn(&{base}, &{old}, &{new})"

    def _emit_set_expr(self, node: dict) -> str:
        items = node.get("items", [])
        if not items:
            return "make_set(vec![])"
        item_strs = [self.emit_expr(item) for item in items]
        return "make_set(vec![" + ", ".join(item_strs) + "])"

    def _emit_set_has(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        value = self.emit_expr(node.get("value"))
        return f"set_has(&{base}, &{value})"

    def _emit_set_size(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"set_size(&{base})"

    def _emit_deque_new(self, node: dict) -> str:
        return "deque_new()"

    def _emit_deque_size(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"deque_size(&{base})"

    def _emit_heap_new(self, node: dict) -> str:
        return "heap_new()"

    def _emit_heap_size(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"heap_size(&{base})"

    def _emit_heap_peek(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        return f"heap_peek(&{base})"

    def _emit_math(self, node: dict) -> str:
        op = node.get("op")
        arg = self.emit_expr(node.get("arg"))
        math_funcs = {
            "sin": "math_sin",
            "cos": "math_cos",
            "tan": "math_tan",
            "sqrt": "math_sqrt",
            "floor": "math_floor",
            "ceil": "math_ceil",
            "abs": "math_abs",
            "log": "math_log",
            "exp": "math_exp",
        }
        if op not in math_funcs:
            raise ValueError(f"unknown math operation: {op}")
        return f"{math_funcs[op]}(&{arg})"

    def _emit_math_pow(self, node: dict) -> str:
        base = self.emit_expr(node.get("base"))
        exponent = self.emit_expr(node.get("exponent"))
        return f"math_pow(&{base}, &{exponent})"

    def _emit_math_const(self, node: dict) -> str:
        name = node.get("name")
        if name == "pi":
            return "math_pi()"
        elif name == "e":
            return "math_e()"
        raise ValueError(f"unknown math constant: {name}")

    def _emit_json_parse(self, node: dict) -> str:
        source = self.emit_expr(node.get("source"))
        return f"json_parse_val(&{source})"

    def _emit_json_stringify(self, node: dict) -> str:
        value = self.emit_expr(node.get("value"))
        pretty = node.get("pretty")
        if pretty:
            pretty_expr = self.emit_expr(pretty)
            return f"json_stringify_val(&{value}, &{pretty_expr})"
        return f"json_stringify_val(&{value}, &Value::Bool(false))"

    def _emit_regex_match(self, node: dict) -> str:
        string = self.emit_expr(node.get("string"))
        pattern = self.emit_expr(node.get("pattern"))
        flags_node = node.get("flags")
        if flags_node:
            flags = self.emit_expr(flags_node)
            return f"regex_match_val(&{string}, &{pattern}, &{flags})"
        return f"regex_match_val(&{string}, &{pattern}, &Value::None)"

    def _emit_regex_find_all(self, node: dict) -> str:
        string = self.emit_expr(node.get("string"))
        pattern = self.emit_expr(node.get("pattern"))
        flags_node = node.get("flags")
        if flags_node:
            flags = self.emit_expr(flags_node)
            return f"regex_find_all_val(&{string}, &{pattern}, &{flags})"
        return f"regex_find_all_val(&{string}, &{pattern}, &Value::None)"

    def _emit_regex_replace(self, node: dict) -> str:
        string = self.emit_expr(node.get("string"))
        pattern = self.emit_expr(node.get("pattern"))
        replacement = self.emit_expr(node.get("replacement"))
        flags_node = node.get("flags")
        if flags_node:
            flags = self.emit_expr(flags_node)
            return f"regex_replace_val(&{string}, &{pattern}, &{replacement}, &{flags})"
        return f"regex_replace_val(&{string}, &{pattern}, &{replacement}, &Value::None)"

    def _emit_regex_split(self, node: dict) -> str:
        string = self.emit_expr(node.get("string"))
        pattern = self.emit_expr(node.get("pattern"))
        flags_node = node.get("flags")
        if flags_node:
            flags = self.emit_expr(flags_node)
            return f"regex_split_val(&{string}, &{pattern}, &{flags})"
        return f"regex_split_val(&{string}, &{pattern}, &Value::None)"

    def _emit_external_call(self, node: dict) -> str:
        module = node.get("module")
        function = node.get("function")
        self.external_modules.add(module)
        raise ValueError(
            f"ExternalCall to {module}.{function} is not supported in Rust backend. "
            f"External calls require platform-specific implementation."
        )

    def _emit_method_call(self, node: dict) -> str:
        obj = self.emit_expr(node.get("object"))
        method = node.get("method")
        args = node.get("args", [])
        arg_strs = [self.emit_expr(arg) for arg in args]
        return f"{obj}.{method}({', '.join(arg_strs)})"

    def _emit_property_get(self, node: dict) -> str:
        obj = self.emit_expr(node.get("object"))
        prop = node.get("property")
        return f"{obj}.{prop}"

    def _emit_to_int(self, node: dict) -> str:
        value = self.emit_expr(node.get("value"))
        return f"value_to_int(&{value})"

    def _emit_to_float(self, node: dict) -> str:
        value = self.emit_expr(node.get("value"))
        return f"value_to_float(&{value})"

    def _emit_to_string(self, node: dict) -> str:
        value = self.emit_expr(node.get("value"))
        return f"value_to_string_convert(&{value})"

    # ========== Statement Handlers ==========

    def _emit_let(self, node: dict) -> None:
        name = node.get("name")
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"let mut {name} = {value};")

    def _emit_assign(self, node: dict) -> None:
        name = node.get("name")
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"{name} = {value};")

    def _emit_if(self, node: dict) -> None:
        test = self.emit_expr(node.get("test"))
        self.emit_line(f"if is_truthy(&{test}) {{")
        self.indent_level += 1
        then_body = node.get("then", [])
        if not then_body:
            self.emit_line("// empty")
        else:
            for stmt in then_body:
                self.emit_stmt(stmt)
        self.indent_level -= 1

        else_body = node.get("else")
        if else_body:
            self.emit_line("} else {")
            self.indent_level += 1
            for stmt in else_body:
                self.emit_stmt(stmt)
            self.indent_level -= 1
        self.emit_line("}")

    def _emit_while(self, node: dict) -> None:
        test_expr = node.get("test")
        test = self.emit_expr(test_expr)
        self.emit_line("loop {")
        self.indent_level += 1
        self.emit_line(f"let __test = {test};")
        self.emit_line("if !is_truthy(&__test) { break; }")
        body = node.get("body", [])
        if not body:
            self.emit_line("// empty")
        else:
            for stmt in body:
                self.emit_stmt(stmt)
        self.indent_level -= 1
        self.emit_line("}")

    def _emit_print(self, node: dict) -> None:
        args = node.get("args", [])
        arg_strs = [self.emit_expr(arg) for arg in args]
        self.emit_line(f"coreil_print(&[{', '.join(arg_strs)}]);")

    def _emit_set_index(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        index = self.emit_expr(node.get("index"))
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"array_set_index(&{base}, &{index}, {value});")

    def _emit_set_stmt(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        key = self.emit_expr(node.get("key"))
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"map_set(&{base}, {key}, {value});")

    def _emit_push(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"array_push(&{base}, {value});")

    def _emit_set_field(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        name = node.get("name")
        value = self.emit_expr(node.get("value"))
        self.emit_line(f'record_set_field(&{base}, "{name}", {value});')

    def _emit_set_add(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"set_add(&{base}, {value});")

    def _emit_set_remove(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"set_remove(&{base}, &{value});")

    def _emit_push_back(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"deque_push_back(&{base}, {value});")

    def _emit_push_front(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"deque_push_front(&{base}, {value});")

    def _emit_pop_front(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        target = node.get("target")
        self.emit_line(f"let mut {target} = deque_pop_front(&{base});")

    def _emit_pop_back(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        target = node.get("target")
        self.emit_line(f"let mut {target} = deque_pop_back(&{base});")

    def _emit_heap_push(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        priority = self.emit_expr(node.get("priority"))
        value = self.emit_expr(node.get("value"))
        self.emit_line(f"heap_push(&{base}, {priority}, {value});")

    def _emit_heap_pop(self, node: dict) -> None:
        base = self.emit_expr(node.get("base"))
        target = node.get("target")
        self.emit_line(f"let mut {target} = heap_pop(&{base});")

    def _emit_func_def(self, node: dict) -> None:
        name = node.get("name")
        params = node.get("params", [])
        param_strs = [f"{p}: Value" for p in params]
        self.emit_line(f"fn {name}({', '.join(param_strs)}) -> Value {{")
        self.indent_level += 1
        body = node.get("body", [])
        if not body:
            self.emit_line("Value::None")
        else:
            for stmt in body:
                self.emit_stmt(stmt)
            # Add implicit return if no explicit return
            if body and body[-1].get("type") != "Return":
                self.emit_line("Value::None")
        self.indent_level -= 1
        self.emit_line("}")

    def _emit_return(self, node: dict) -> None:
        value = node.get("value")
        if value is None:
            self.emit_line("return Value::None;")
        else:
            self.emit_line(f"return {self.emit_expr(value)};")

    def _emit_call_stmt(self, node: dict) -> None:
        name = node.get("name")
        args = node.get("args", [])

        if name == "append":
            if len(args) != 2:
                raise ValueError(f"append expects 2 arguments, got {len(args)}")
            lst = self.emit_expr(args[0])
            value = self.emit_expr(args[1])
            self.emit_line(f"array_push(&{lst}, {value});")
            return

        arg_strs = [self.emit_expr(arg) + ".clone()" for arg in args]
        self.emit_line(f"{name}({', '.join(arg_strs)});")

    def _emit_break(self, node: dict) -> None:
        self.emit_line("break;")

    def _emit_continue(self, node: dict) -> None:
        self.emit_line("continue;")

    def _emit_for(self, node: dict) -> None:
        var = node.get("var")
        iter_expr = node.get("iter")
        body = node.get("body", [])

        # Handle Range iterator
        if isinstance(iter_expr, dict) and iter_expr.get("type") == "Range":
            from_val = self.emit_expr(iter_expr.get("from"))
            to_val = self.emit_expr(iter_expr.get("to"))
            inclusive = iter_expr.get("inclusive", False)
            cmp_op = "<=" if inclusive else "<"
            self.emit_line("{")
            self.indent_level += 1
            self.emit_line(f"let mut __from = as_int(&{from_val});")
            self.emit_line(f"let __to = as_int(&{to_val});")
            self.emit_line(f"while __from {cmp_op} __to {{")
            self.indent_level += 1
            self.emit_line(f"let mut {var} = Value::Int(__from);")
            for stmt in body:
                self.emit_stmt(stmt)
            self.emit_line("__from += 1;")
            self.indent_level -= 1
            self.emit_line("}")
            self.indent_level -= 1
            self.emit_line("}")
        else:
            iter_code = self.emit_expr(iter_expr)
            self.emit_line("{")
            self.indent_level += 1
            self.emit_line(f"let __iter = {iter_code};")
            self.emit_line('let __arr = match &__iter { Value::Array(a) => a.borrow().clone(), _ => panic!("expected array") };')
            self.emit_line("for __item in __arr.iter() {")
            self.indent_level += 1
            self.emit_line(f"let mut {var} = __item.clone();")
            for stmt in body:
                self.emit_stmt(stmt)
            self.indent_level -= 1
            self.emit_line("}")
            self.indent_level -= 1
            self.emit_line("}")

    def _emit_for_each(self, node: dict) -> None:
        var = node.get("var")
        iter_code = self.emit_expr(node.get("iter"))
        body = node.get("body", [])

        self.emit_line("{")
        self.indent_level += 1
        self.emit_line(f"let __iter = {iter_code};")
        self.emit_line('let __arr = match &__iter { Value::Array(a) => a.borrow().clone(), _ => panic!("expected array") };')
        self.emit_line("for __item in __arr.iter() {")
        self.indent_level += 1
        self.emit_line(f"let mut {var} = __item.clone();")
        if not body:
            self.emit_line("// empty")
        else:
            for stmt in body:
                self.emit_stmt(stmt)
        self.indent_level -= 1
        self.emit_line("}")
        self.indent_level -= 1
        self.emit_line("}")

    def _emit_throw(self, node: dict) -> None:
        message = self.emit_expr(node.get("message"))
        self.emit_line(f'panic!("{{}}", format_value(&{message}));')

    def _emit_try_catch(self, node: dict) -> None:
        catch_var = node.get("catch_var")
        body = node.get("body", [])
        catch_body = node.get("catch_body", [])
        finally_body = node.get("finally_body")

        if not finally_body:
            # Simple case: no finally block
            self.emit_line("{")
            self.indent_level += 1
            self.emit_line("let __result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {")
            self.indent_level += 1
            for stmt in body:
                self.emit_stmt(stmt)
            self.indent_level -= 1
            self.emit_line("}));")
            self.emit_line("match __result {")
            self.indent_level += 1
            self.emit_line("Ok(()) => {},")
            self.emit_line("Err(__e) => {")
            self.indent_level += 1
            self._emit_catch_var_binding(catch_var, "__e")
            for stmt in catch_body:
                self.emit_stmt(stmt)
            self.indent_level -= 1
            self.emit_line("}")
            self.indent_level -= 1
            self.emit_line("}")
            self.indent_level -= 1
            self.emit_line("}")
        else:
            # With finally: wrap catch body in its own catch_unwind
            # so finally always executes even if catch body panics
            self.emit_line("{")
            self.indent_level += 1
            self.emit_line("let mut __pending_panic: Option<Box<dyn std::any::Any + Send>> = None;")
            self.emit_line("let __result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {")
            self.indent_level += 1
            for stmt in body:
                self.emit_stmt(stmt)
            self.indent_level -= 1
            self.emit_line("}));")
            self.emit_line("match __result {")
            self.indent_level += 1
            self.emit_line("Ok(()) => {},")
            self.emit_line("Err(__e) => {")
            self.indent_level += 1
            self._emit_catch_var_binding(catch_var, "__e")
            self.emit_line("let __catch_result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {")
            self.indent_level += 1
            for stmt in catch_body:
                self.emit_stmt(stmt)
            self.indent_level -= 1
            self.emit_line("}));")
            self.emit_line("if let Err(__catch_panic) = __catch_result {")
            self.indent_level += 1
            self.emit_line("__pending_panic = Some(__catch_panic);")
            self.indent_level -= 1
            self.emit_line("}")
            self.indent_level -= 1
            self.emit_line("}")
            self.indent_level -= 1
            self.emit_line("}")
            for stmt in finally_body:
                self.emit_stmt(stmt)
            self.emit_line("if let Some(__p) = __pending_panic {")
            self.indent_level += 1
            self.emit_line("std::panic::resume_unwind(__p);")
            self.indent_level -= 1
            self.emit_line("}")
            self.indent_level -= 1
            self.emit_line("}")

    def _emit_catch_var_binding(self, catch_var: str, err_var: str) -> None:
        """Emit the catch variable binding from a caught panic payload."""
        self.emit_line(f"let mut {catch_var} = Value::Str(")
        self.indent_level += 1
        self.emit_line(f'{err_var}.downcast_ref::<String>().map(|s| s.clone())')
        self.emit_line(f'    .or_else(|| {err_var}.downcast_ref::<&str>().map(|s| s.to_string()))')
        self.emit_line('    .unwrap_or_else(|| "unknown error".to_string())')
        self.indent_level -= 1
        self.emit_line(");")

    def _emit_switch(self, node: dict) -> None:
        test = self.emit_expr(node.get("test"))
        cases = node.get("cases", [])
        default = node.get("default")
        self.emit_line("{")
        self.indent_level += 1
        self.emit_line(f"let __switch_val = {test};")
        for i, case in enumerate(cases):
            case_val = self.emit_expr(case["value"])
            keyword = "if" if i == 0 else "} else if"
            self.emit_line(f"{keyword} value_equal(&__switch_val, &{case_val}) {{")
            self.indent_level += 1
            for stmt in case.get("body", []):
                self.emit_stmt(stmt)
            self.indent_level -= 1
        if default is not None:
            self.emit_line("} else {")
            self.indent_level += 1
            for stmt in default:
                self.emit_stmt(stmt)
            self.indent_level -= 1
        self.emit_line("}")
        self.indent_level -= 1
        self.emit_line("}")


def emit_rust(doc: dict) -> tuple[str, dict[int, list[int]]]:
    """Generate Rust code from Core IL document.

    Returns a tuple of (Rust source code, coreil_line_map).
    The coreil_line_map maps Core IL body statement indices to output line numbers.
    """
    emitter = RustEmitter(doc)
    code = emitter.emit()
    return code, emitter.coreil_line_map


def get_runtime_path() -> Path:
    """Return the path to the coreil_runtime.rs runtime file."""
    return Path(__file__).parent / "rust_runtime" / "coreil_runtime.rs"
